# -*- coding: utf-8 -*-

"""
Copyright 2025 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import asyncio
import inspect
import json
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Mapping, Optional, Protocol, Sequence, Union, cast

from dapr.clients.grpc import _conversation_helpers as conv_helpers
from dapr.proto import api_v1

Params = Union[Mapping[str, Any], Sequence[Any], None]


@dataclass
class ConversationInput:
    """A single input message for the conversation."""

    content: str
    role: Optional[str] = None
    scrub_pii: Optional[bool] = None


@dataclass
class ConversationMessageContent:
    """Content for conversation messages."""

    text: str


def _indent_lines(title: str, text: str, indent: int) -> str:
    """Indent lines of text."""
    indent_after_first_line = indent + len(title) + 2
    lines = text.splitlines() if text is not None else ['']
    first = lines[0] if lines else ''
    rest = ''
    for line in lines[1:]:
        rest += f'\n{indent_after_first_line * " "}{line}'
    return f'{indent * " "}{title}: {first}{rest}'


@dataclass
class ConversationMessageOfDeveloper:
    """Developer message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)

    def trace_print(self, indent: int = 0) -> None:
        base = ' ' * indent
        if self.name:
            print(f'{base}name: {self.name}')
        for i, c in enumerate(self.content):
            print(_indent_lines(f'content[{i}]', c.text, indent))


@dataclass
class ConversationMessageOfSystem:
    """System message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)

    def trace_print(self, indent: int = 0) -> None:
        base = ' ' * indent
        if self.name:
            print(f'{base}name: {self.name}')
        for i, c in enumerate(self.content):
            print(_indent_lines(f'content[{i}]', c.text, indent))


@dataclass
class ConversationMessageOfUser:
    """User message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)

    def trace_print(self, indent: int = 0) -> None:
        base = ' ' * indent
        if self.name:
            print(f'{base}name: {self.name}')
        for i, c in enumerate(self.content):
            print(_indent_lines(f'content[{i}]', c.text, indent))


@dataclass
class ConversationToolCallsOfFunction:
    """Function call details within a tool call."""

    name: str
    arguments: str


@dataclass
class ConversationToolCalls:
    """Tool calls generated by the model."""

    id: Optional[str] = None
    function: Optional[ConversationToolCallsOfFunction] = None


@dataclass
class ConversationMessageOfAssistant:
    """Assistant message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)
    tool_calls: List[ConversationToolCalls] = field(default_factory=list)

    def trace_print(self, indent: int = 0) -> None:
        base = ' ' * indent
        if self.name:
            print(f'{base}name: {self.name}')
        for i, c in enumerate(self.content):
            lines = c.text.splitlines() if c.text is not None else ['']
            first = lines[0] if lines else ''
            print(f'{base}content[{i}]: {first}')
            for extra in lines[1:]:
                print(extra)
        if self.tool_calls:
            print(f'{base}tool_calls: {len(self.tool_calls)}')
            for idx, tc in enumerate(self.tool_calls):
                tc_id = tc.id or ''
                fn = tc.function.name if tc.function else ''
                args = tc.function.arguments if tc.function else ''
                print(f'{base}  [{idx}] id={tc_id} function={fn}({args})')


@dataclass
class ConversationMessageOfTool:
    """Tool message content."""

    tool_id: Optional[str] = None
    name: str = ''
    content: List[ConversationMessageContent] = field(default_factory=list)

    def trace_print(self, indent: int = 0) -> None:
        base = ' ' * indent
        if self.tool_id:
            print(f'{base}tool_id: {self.tool_id}')
        if self.name:
            print(f'{base}name: {self.name}')
        for i, c in enumerate(self.content):
            lines = c.text.splitlines() if c.text is not None else ['']
            first = lines[0] if lines else ''
            print(f'{base}content[{i}]: {first}')
            for extra in lines[1:]:
                print(extra)


@dataclass
class ConversationMessage:
    """Conversation message with different role types."""

    of_developer: Optional[ConversationMessageOfDeveloper] = None
    of_system: Optional[ConversationMessageOfSystem] = None
    of_user: Optional[ConversationMessageOfUser] = None
    of_assistant: Optional[ConversationMessageOfAssistant] = None
    of_tool: Optional[ConversationMessageOfTool] = None

    def trace_print(self, indent: int = 0):
        print()
        """Print the conversation message with indentation and direction arrows."""
        if self.of_developer:
            print(f'{" " * indent}client[developer] ---------> LLM[assistant]:')
            self.of_developer.trace_print(indent + 2)
        if self.of_system:
            print(f'{" " * indent}client[system]    ---------> LLM[assistant]:')
            self.of_system.trace_print(indent + 2)
        if self.of_user:
            print(f'{" " * indent}client[user]      ---------> LLM[assistant]:')
            self.of_user.trace_print(indent + 2)
        if self.of_assistant:
            print(f'{" " * indent}client            <-------- LLM[assistant]:')
            self.of_assistant.trace_print(indent + 2)
        if self.of_tool:
            print(f'{" " * indent}client[tool]      --------> LLM[assistant]:')
            self.of_tool.trace_print(indent + 2)

    def to_proto(self) -> api_v1.ConversationMessage:
        """Convert a conversation message to proto format."""

        def _convert_message_content_to_proto(
            content_list: List[ConversationMessageContent],
        ):
            """Convert message content list to proto format."""
            if not content_list:
                return []
            return [
                api_v1.ConversationMessageContent(text=content.text) for content in content_list
            ]

        def _convert_tool_calls_to_proto(tool_calls: List[ConversationToolCalls]):
            """Convert tool calls to proto format."""
            if not tool_calls:
                return []
            proto_calls = []
            for call in tool_calls:
                proto_call = api_v1.ConversationToolCalls()
                if call.id:
                    proto_call.id = call.id
                if call.function:
                    proto_call.function.name = call.function.name
                    proto_call.function.arguments = call.function.arguments
                proto_calls.append(proto_call)
            return proto_calls

        proto_message = api_v1.ConversationMessage()

        if self.of_developer:
            proto_message.of_developer.name = self.of_developer.name or ''
            proto_message.of_developer.content.extend(
                _convert_message_content_to_proto(self.of_developer.content or [])
            )
        elif self.of_system:
            proto_message.of_system.name = self.of_system.name or ''
            proto_message.of_system.content.extend(
                _convert_message_content_to_proto(self.of_system.content or [])
            )
        elif self.of_user:
            proto_message.of_user.name = self.of_user.name or ''
            proto_message.of_user.content.extend(
                _convert_message_content_to_proto(self.of_user.content or [])
            )
        elif self.of_assistant:
            proto_message.of_assistant.name = self.of_assistant.name or ''
            proto_message.of_assistant.content.extend(
                _convert_message_content_to_proto(self.of_assistant.content or [])
            )
            proto_message.of_assistant.tool_calls.extend(
                _convert_tool_calls_to_proto(self.of_assistant.tool_calls or [])
            )
        elif self.of_tool:
            if self.of_tool.tool_id:
                proto_message.of_tool.tool_id = self.of_tool.tool_id
            proto_message.of_tool.name = self.of_tool.name
            proto_message.of_tool.content.extend(
                _convert_message_content_to_proto(self.of_tool.content or [])
            )

        return proto_message


@dataclass
class ConversationInputAlpha2:
    """Alpha2 input message for conversation API."""

    messages: List[ConversationMessage]
    scrub_pii: Optional[bool] = None


@dataclass
class ConversationToolsFunction:
    """Function definition for conversation tools."""

    name: str
    description: Optional[str] = None
    parameters: Optional[Dict] = None

    def schema_as_dict(self) -> Dict:
        """Return the function's schema as a dictionary.

        Returns:
            Dict: The JSON schema for the function parameters.
        """
        return self.parameters or {}

    @classmethod
    def from_function(cls, func: Callable, register: bool = True) -> 'ConversationToolsFunction':
        """Create a ConversationToolsFunction from a function.

        Args:
            func: The function to extract the schema from.
            register: Whether to register the function in the tool registry.
        """
        c = cls(
            name=func.__name__,
            description=conv_helpers.extract_docstring_summary(func),
            parameters=conv_helpers.function_to_json_schema(func),
        )
        if register:
            register_tool(c.name, ConversationTools(function=c, backend=FunctionBackend(func)))
        return c


# ------------------------------------------------------------------------------------------------
# Tool Helpers
# ------------------------------------------------------------------------------------------------


class ToolBackend(Protocol):
    """Interface for executors that knows how to execute a tool call."""

    def invoke(self, spec: ConversationToolsFunction, params: Params) -> Any:
        ...

    async def ainvoke(
        self, spec: ConversationToolsFunction, params: Params, *, timeout: Union[float, None] = None
    ) -> Any:
        ...


@dataclass
class FunctionBackend:
    """A backend that executes a local function."""

    func: Callable[..., Any] = field(repr=False)

    def invoke(self, spec: ConversationToolsFunction, params: Params) -> Any:
        bound = conv_helpers.bind_params_to_func(self.func, params)
        if inspect.iscoroutinefunction(self.func):
            raise conv_helpers.ToolExecutionError(
                "This tool is async; use 'await tool.ainvoke(...)'."
            )
        try:
            return self.func(*bound.args, **bound.kwargs)
        except Exception as e:
            raise conv_helpers.ToolExecutionError(f'Tool raised: {e}') from e

    async def ainvoke(
        self, spec: ConversationToolsFunction, params: Params, *, timeout: Union[float, None] = None
    ) -> Any:
        bound = conv_helpers.bind_params_to_func(self.func, params)
        try:
            if inspect.iscoroutinefunction(self.func):
                coro = self.func(*bound.args, **bound.kwargs)
                return await (asyncio.wait_for(coro, timeout) if timeout else coro)
            loop = asyncio.get_running_loop()
            return await loop.run_in_executor(None, lambda: self.func(*bound.args, **bound.kwargs))
        except asyncio.TimeoutError as err:
            raise conv_helpers.ToolExecutionError(f'Timed out after {timeout} seconds') from err
        except Exception as e:
            raise conv_helpers.ToolExecutionError(f'Tool raised: {e}') from e


def tool(
    func: Optional[Callable] = None,
    *,
    name: Optional[str] = None,
    description: Optional[str] = None,
    namespace: Optional[str] = None,
    register: bool = True,
):
    """
    Decorate a callable as a conversation tool.
    """

    def _decorate(f: Callable):
        ctf = ConversationToolsFunction.from_function(f, register=False)

        # Prefix name with namespace/module if not provided explicitly
        ns = namespace or ''
        if ns:
            ns += '.'
        ctf.name = name or f'{ns}{ctf.name}'

        if description:
            ctf.description = description

        ct = ConversationTools(function=ctf, backend=FunctionBackend(f))

        # Store the tool in the function for later retrieval (mypy-safe without setattr)
        cast(Any, f).__dapr_conversation_tool__ = ct

        if register:
            register_tool(ctf.name, ct)

        return f

    return _decorate if func is None else _decorate(func)


@dataclass
class ConversationTools:
    """Tools available for conversation."""

    # currently only function is supported
    function: ConversationToolsFunction
    backend: Optional[ToolBackend] = None

    def invoke(self, params: Params = None) -> Any:
        if not self.backend:
            raise conv_helpers.ToolExecutionError('Tool backend not set')
        return self.backend.invoke(self.function, params)

    async def ainvoke(self, params: Params = None, *, timeout: Union[float, None] = None) -> Any:
        if not self.backend:
            raise conv_helpers.ToolExecutionError('Tool backend not set')
        return await self.backend.ainvoke(self.function, params, timeout=timeout)


# registry of tools
_TOOL_REGISTRY: Dict[str, ConversationTools] = {}


def register_tool(name: str, t: ConversationTools):
    if name in _TOOL_REGISTRY:
        raise ValueError(f"Tool '{name}' already registered")
    _TOOL_REGISTRY[name] = t


def unregister_tool(name: str):
    """Unregister a tool. Good for cleanup and avoid collisions."""
    if name in _TOOL_REGISTRY:
        del _TOOL_REGISTRY[name]


def get_registered_tools() -> List[ConversationTools]:
    """Get a list of all registered tools. This can be pass as tools in the ConversationInput."""
    return list(_TOOL_REGISTRY.values())


def _get_tool(name: str) -> ConversationTools:
    try:
        return _TOOL_REGISTRY[name]
    except KeyError as err:
        raise conv_helpers.ToolNotFoundError(f"Tool '{name}' is not registered") from err


def execute_registered_tool(name: str, params: Union[Params, str] = None) -> Any:
    """Execute a registered tool."""
    if isinstance(params, str):
        params = json.loads(params)
    return _get_tool(name).invoke(params)


async def execute_registered_tool_async(
    name: str, params: Union[Params, str] = None, *, timeout: Union[float, None] = None
) -> Any:
    """Execute a registered tool asynchronously."""
    if isinstance(params, str):
        params = json.loads(params)
    return await _get_tool(name).ainvoke(params, timeout=timeout)


# ------------------------------------------------------------------------------------------------
# Helpers to create messages for Alpha2 inputs
# ------------------------------------------------------------------------------------------------


def create_user_message(text: str) -> ConversationMessage:
    """Helper to create a user message for Alpha2."""
    return ConversationMessage(
        of_user=ConversationMessageOfUser(content=[ConversationMessageContent(text=text)])
    )


def create_system_message(text: str) -> ConversationMessage:
    """Helper to create a system message for Alpha2."""
    return ConversationMessage(
        of_system=ConversationMessageOfSystem(content=[ConversationMessageContent(text=text)])
    )


def create_assistant_message(text: str) -> ConversationMessage:
    """Helper to create an assistant message for Alpha2."""
    return ConversationMessage(
        of_assistant=ConversationMessageOfAssistant(content=[ConversationMessageContent(text=text)])
    )


def create_tool_message(tool_id: str, name: str, content: str) -> ConversationMessage:
    """Helper to create a tool message for Alpha2 responses (from client to LLM)."""
    return ConversationMessage(
        of_tool=ConversationMessageOfTool(
            tool_id=tool_id, name=name, content=[ConversationMessageContent(text=content)]
        )
    )
