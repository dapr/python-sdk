from dapr.clients.grpc import _conversation_helpers as conv_helpers
from dapr.proto import api_v1

import asyncio
import inspect
import json
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Mapping, Optional, Sequence, Union, Protocol

Params = Union[Mapping[str, Any], Sequence[Any], None]


@dataclass
class ConversationInput:
    """A single input message for the conversation."""

    content: str
    role: Optional[str] = None
    scrub_pii: Optional[bool] = None


@dataclass
class ConversationMessageContent:
    """Content for conversation messages."""

    text: str


@dataclass
class ConversationMessageOfDeveloper:
    """Developer message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)


@dataclass
class ConversationMessageOfSystem:
    """System message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)


@dataclass
class ConversationMessageOfUser:
    """User message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)


@dataclass
class ConversationToolCallsOfFunction:
    """Function call details within a tool call."""

    name: str
    arguments: str


@dataclass
class ConversationToolCalls:
    """Tool calls generated by the model."""

    id: Optional[str] = None
    function: Optional[ConversationToolCallsOfFunction] = None


@dataclass
class ConversationMessageOfAssistant:
    """Assistant message content."""

    name: Optional[str] = None
    content: List[ConversationMessageContent] = field(default_factory=list)
    tool_calls: List[ConversationToolCalls] = field(default_factory=list)


@dataclass
class ConversationMessageOfTool:
    """Tool message content."""

    tool_id: Optional[str] = None
    name: str = ''
    content: List[ConversationMessageContent] = field(default_factory=list)


@dataclass
class ConversationMessage:
    """Conversation message with different role types."""

    of_developer: Optional[ConversationMessageOfDeveloper] = None
    of_system: Optional[ConversationMessageOfSystem] = None
    of_user: Optional[ConversationMessageOfUser] = None
    of_assistant: Optional[ConversationMessageOfAssistant] = None
    of_tool: Optional[ConversationMessageOfTool] = None

    def to_proto(self) -> api_v1.ConversationMessage:
        """Convert a conversation message to proto format."""

        def _convert_message_content_to_proto(
            content_list: List[ConversationMessageContent],
        ):
            """Convert message content list to proto format."""
            if not content_list:
                return []
            return [
                api_v1.ConversationMessageContent(text=content.text) for content in content_list
            ]

        def _convert_tool_calls_to_proto(tool_calls: List[ConversationToolCalls]):
            """Convert tool calls to proto format."""
            if not tool_calls:
                return []
            proto_calls = []
            for call in tool_calls:
                proto_call = api_v1.ConversationToolCalls()
                if call.id:
                    proto_call.id = call.id
                if call.function:
                    proto_call.function.name = call.function.name
                    proto_call.function.arguments = call.function.arguments
                proto_calls.append(proto_call)
            return proto_calls

        proto_message = api_v1.ConversationMessage()

        if self.of_developer:
            proto_message.of_developer.name = self.of_developer.name or ''
            proto_message.of_developer.content.extend(
                _convert_message_content_to_proto(self.of_developer.content or [])
            )
        elif self.of_system:
            proto_message.of_system.name = self.of_system.name or ''
            proto_message.of_system.content.extend(
                _convert_message_content_to_proto(self.of_system.content or [])
            )
        elif self.of_user:
            proto_message.of_user.name = self.of_user.name or ''
            proto_message.of_user.content.extend(
                _convert_message_content_to_proto(self.of_user.content or [])
            )
        elif self.of_assistant:
            proto_message.of_assistant.name = self.of_assistant.name or ''
            proto_message.of_assistant.content.extend(
                _convert_message_content_to_proto(self.of_assistant.content or [])
            )
            proto_message.of_assistant.tool_calls.extend(
                _convert_tool_calls_to_proto(self.of_assistant.tool_calls or [])
            )
        elif self.of_tool:
            if self.of_tool.tool_id:
                proto_message.of_tool.tool_id = self.of_tool.tool_id
            proto_message.of_tool.name = self.of_tool.name
            proto_message.of_tool.content.extend(
                _convert_message_content_to_proto(self.of_tool.content or [])
            )

        return proto_message


@dataclass
class ConversationInputAlpha2:
    """Alpha2 input message for conversation API."""

    messages: List[ConversationMessage]
    scrub_pii: Optional[bool] = None


@dataclass
class ConversationToolsFunction:
    """Function definition for conversation tools."""

    name: str
    description: Optional[str] = None
    parameters: Optional[Dict] = None

    def schema_as_dict(self) -> Dict:
        """Return the function's schema as a dictionary.

        Returns:
            Dict: The JSON schema for the function parameters.
        """
        return self.parameters or {}

    @classmethod
    def from_function(cls, func: Callable, register: bool = True) -> 'ConversationToolsFunction':
        """Create a ConversationToolsFunction from a function.

        Args:
            func: The function to extract the schema from.
            register: Whether to register the function in the tool registry.
        """
        c = cls(
            name=func.__name__,
            description=conv_helpers.extract_docstring_summary(func),
            parameters=conv_helpers.function_to_json_schema(func),
        )
        if register:
            register_tool(c.name, ConversationTools(function=c, backend=FunctionBackend(func)))
        return c

# --- Tool Helpers


class ToolBackend(Protocol):
    """Interface for executors that knows how to execute a tool call."""

    def invoke(self, spec: ConversationToolsFunction, params: Params) -> Any:
        ...

    async def ainvoke(
        self, spec: ConversationToolsFunction, params: Params, *, timeout: Union[float , None] = None
    ) -> Any:
        ...


@dataclass
class FunctionBackend:
    """A backend that executes a local function."""

    func: Callable[..., Any] = field(repr=False)

    def invoke(self, spec: ConversationToolsFunction, params: Params) -> Any:
        bound = conv_helpers.bind_params_to_func(self.func, params)
        if inspect.iscoroutinefunction(self.func):
            raise conv_helpers.ToolExecutionError(
                "This tool is async; use 'await tool.ainvoke(...)'."
            )
        try:
            return self.func(*bound.args, **bound.kwargs)
        except Exception as e:
            raise conv_helpers.ToolExecutionError(f'Tool raised: {e}') from e

    async def ainvoke(
        self, spec: ConversationToolsFunction, params: Params, *, timeout: Union[float , None] = None
    ) -> Any:
        bound = conv_helpers.bind_params_to_func(self.func, params)
        try:
            if inspect.iscoroutinefunction(self.func):
                coro = self.func(*bound.args, **bound.kwargs)
                return await (asyncio.wait_for(coro, timeout) if timeout else coro)
            loop = asyncio.get_running_loop()
            return await loop.run_in_executor(None, lambda: self.func(*bound.args, **bound.kwargs))
        except asyncio.TimeoutError:
            raise conv_helpers.ToolExecutionError(f'Timed out after {timeout} seconds')
        except Exception as e:
            raise conv_helpers.ToolExecutionError(f'Tool raised: {e}') from e


def tool(
    func: Callable,
    *,
    name: Optional[str] = None,
    description: Optional[str] = None,
    namespace: Optional[str] = None,
    register: bool = True,
):
    """
    Decorate a callable as a conversation tool.
    """

    def _decorate(f: Callable):
        ctf = ConversationToolsFunction.from_function(f, register=False)

        # Prefix name with namespace/module if not provided explicitly
        ns = namespace or ''
        if ns:
            ns += '.'
        ctf.name = name or f'{ns}{ctf.name}'

        if description:
            ctf.description = description

        ct = ConversationTools(function=ctf, backend=FunctionBackend(f))

        setattr(f, '__dapr_conversation_tool__', ct)

        if register:
            register_tool(ctf.name, ct)

        return f

    return _decorate if func is None else _decorate(func)


@dataclass
class ConversationTools:
    """Tools available for conversation."""

    # currently only function is supported
    function: ConversationToolsFunction
    backend: Optional[ToolBackend] = None

    def invoke(self, params: Params = None) -> Any:
        if not self.backend:
            raise conv_helpers.ToolExecutionError('Tool backend not set')
        return self.backend.invoke(self.function, params)

    async def ainvoke(self, params: Params = None, *, timeout: Union[float , None] = None) -> Any:
        if not self.backend:
            raise conv_helpers.ToolExecutionError('Tool backend not set')
        return await self.backend.ainvoke(self.function, params, timeout=timeout)


# registry of tools
_TOOL_REGISTRY: Dict[str, ConversationTools] = {}


# whether to allow tool execution. It is set to false to express that you should validate the input of the LLM to
# avoid injection attacks.
_ALLOW_REGISTER_TOOL_EXECUTION = False


def register_tool(name: str, t: ConversationTools):
    if name in _TOOL_REGISTRY:
        raise ValueError(f"Tool '{name}' already registered")
    _TOOL_REGISTRY[name] = t


def unregister_tool(name: str):
    """Unregister a tool. Good for cleanup and avoid collisions."""
    if name in _TOOL_REGISTRY:
        del _TOOL_REGISTRY[name]


def get_registered_tools() -> List[ConversationTools]:
    """Get a list of all registered tools. This can be pass as tools in the ConversationInput."""
    return list(_TOOL_REGISTRY.values())


def set_allow_register_tool_execution(allow: bool):
    """Set whether tool execution is allowed."""
    global _ALLOW_REGISTER_TOOL_EXECUTION
    _ALLOW_REGISTER_TOOL_EXECUTION = allow


def _get_tool(name: str) -> ConversationTools:
    try:
        return _TOOL_REGISTRY[name]
    except KeyError:
        raise conv_helpers.ToolNotFoundError(f"Tool '{name}' is not registered")


def execute_registered_tool(name: str, params: Union[Params , str] = None) -> Any:
    """Execute a registered tool."""
    if not _ALLOW_REGISTER_TOOL_EXECUTION:
        raise conv_helpers.ToolExecutionForbiddenError(
            'Automatic tool execution is forbidden. To enable it, set it via set_allow_register_tool_execution'
        )
    if isinstance(params, str):
        params = json.loads(params)
    return _get_tool(name).invoke(params)


async def execute_registered_tool_async(
    name: str, params: Union[Params , str] = None, *, timeout: Union[float , None] = None
) -> Any:
    """Execute a registered tool asynchronously."""
    if not _ALLOW_REGISTER_TOOL_EXECUTION:
        raise conv_helpers.ToolExecutionForbiddenError(
            'Automatic tool execution is forbidden. To enable it, set it via set_allow_register_tool_execution'
        )
    if isinstance(params, str):
        params = json.loads(params)
    return await _get_tool(name).ainvoke(params, timeout=timeout)


# --- Helpers to create messages for Alpha2 inputs


def create_user_message(text: str) -> ConversationMessage:
    """Helper to create a user message for Alpha2."""
    return ConversationMessage(
        of_user=ConversationMessageOfUser(content=[ConversationMessageContent(text=text)])
    )


def create_system_message(text: str) -> ConversationMessage:
    """Helper to create a system message for Alpha2."""
    return ConversationMessage(
        of_system=ConversationMessageOfSystem(content=[ConversationMessageContent(text=text)])
    )


def create_assistant_message(text: str) -> ConversationMessage:
    """Helper to create an assistant message for Alpha2."""
    return ConversationMessage(
        of_assistant=ConversationMessageOfAssistant(content=[ConversationMessageContent(text=text)])
    )


def create_tool_message(tool_id: str, name: str, content: str) -> ConversationMessage:
    """Helper to create a tool message for Alpha2 responses (from client to LLM)."""
    return ConversationMessage(
        of_tool=ConversationMessageOfTool(
            tool_id=tool_id, name=name, content=[ConversationMessageContent(text=content)]
        )
    )
